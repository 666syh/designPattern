# 总结

## 创建型模式：  
    * 抽象工厂
    * 建造者模式
    * 工厂方法
    * 原型法
    * 单例模式  
* 创建者模式隐藏了这些类的实例是如何被创建和放在一起的，整个系统关于这些对象所知道的是由抽象类所定义的接口。这样，创建型模式在创建了什么、谁创建的、它是怎么被创建的，以及何时创建这些方面提供了很大的灵活性
* 当一个系统应该独立于它的产品创建、构成和表示时，应该考虑用创建者模式。建立相应相应数目的原型并克隆它们通常比每次用合适的状态手动实例化该类更方便一些
* 内聚性描述的是一个例程内部组成部分之间相互联系的紧密程度。耦合性描述的是一个例程与其他例程之间联系的紧密程度。软件开发的目标应该是创建这样的例程：内部完整，也就是高内聚，而与其他例程之间的联系则是小巧，直接，灵活，可见的这就是松耦合
* 建造者模式是将一个复杂的对象的构建与其表示分离，这就可以很容易的改变一个产品的内部表示，并且使得构造代码和表示代码分开。这样对于客户来说，他无需关心产品的创建过程，而只需要告诉建造者需要什么，就能够用同样的构建过程创建不同的产品给客户
* 对一些类来说，一个实例是很重要的。一个全局变量可以使得一个对象被访问，但它不能防止客户端实例多个对象，单例模式的优势就是让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建，并且还单例类还提供一个访问该实例的方法。这样就使得对唯一的实例可以严格地控制客户怎样以及何时访问它
* 创建型模式抽象了实例化的过程，它们帮助系统独立于如何创建、组合和表示它的那些对象。创建型模式都会将关于该系统使用哪些具体的类的信息封装起来。允许客户用结构和功能差别很大的产品对象配置一个系统。配置可以是静态的，即在编译时指定，也可以是动态的，即在运行时指定
---
## 结构型模式
    * 适配器模式
    * 桥接模式
    * 组合模式
    * 装饰模式
    * 外观模式
    * 享元模式
    * 代理模式
* 面向对象的精神就是更好地应对需求的变化，而现实中往往会有下面这种情况，想使用一个已经存在的类，而它的接口不符合要求，或者可以创建一个可以复用的类，该类可以与其他不想关的类或不可预见的类协同工作。正如开放封闭所倡导的，对修改关闭，对扩展开放的原则，适配器可以做到让这些接口不同的类通过适配后，协同工作
* 继承是好的东西，但往往会过度地使用，继承会导致类的结构过于复杂，关系太多，难以维护，而更糟糕的是扩展性非常差，而仔细研究如果能发现继承体系中，有两个甚至多个方向的变化，那么就解耦这些不同方向的变化，通过对象组合的方式，把两个角色之间的继承关系改为了组合关系，从而使这两者可以应对独立的变化。事实上就是合成复用提出的规则。面对变化，桥接模式主张找出变化并封装之
* 面对变化，如果采用生成子类的方法进行扩充，为支持每一种扩展的组合，会产生大量子类，使得子类数量呈爆炸性增长。这也是继承所带来的的灾难，而事实上，这些子类多半只是为某个对象增加一些职责，此时通过装饰的方式，可以更加灵活，以动态、透明的方式给单个对象添加职责，并在不需要时，撤销相应的职责
* 组合模式希望用户忽略掉组合对象与单个对象的不同，用户将可以统一地使用组合结构中的所有对象。用户使用组合类接口与组合结构中的对象进行交互，如果接受者是个叶结点，则直接处理请求，如果接受者是组合对象，通常将请求发送给他的子部件，并在转发之前或之后可能执行一些辅助操作。组合模式的效果就是客户可以一致的使用组合结构或是单个对象。任何用到基本对象的地方都可以使用组合对象
* 信息的隐藏促进了软件的复用：类之间的耦合性越低，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。如果两个类不必彼此直接通信，那么就不要让这两个类发生直接的相互作用。如果实在需要调用，可以通过第三者来转发调用
* 对象使得内存占用过多，而且如果都是大量重复的对象，那就是资源的极度浪费，会使得机器性能减慢，面向对象技术有时会因简单化的设计而代价很大。比如文档处理软件，当中的字符都可以是对象，而如果让文档中每一个字符都是一个对象的话，就会产生难以接受的运行开销，显然这是不合理也是没必要的。由于文档字符也就是那么多的字母、数字或符号，完全可以让所有相同的字符都共享一个对象，这样就可以节省大量的内存
* 代理模式与外观模式的主要区别在于，代理对象代表一个单一对象，而外观对象代表一个子系统，代理的客户对象无法直接访问目标对象，由代理提供对单独的目标对象的访问控制，而外观的客户对象可以直接访问子系统中的各个对象，但通常由外观对象提供对子系统各元件功能的简化的共同层次的调用接口。代理模式与适配器模式，其实都属于一种衔接性质的功能。代理是一种原来对象的代表，其他需要与这个对象打交道的操作都是和这个代理交涉。而适配器则不需要虚构出一个代表者。只需要为应付使用目的，将原来的类进行一些组合。
* 适配器主要是为了解决两个已有接口之间不匹配的问题，适配器不需要知道这些接口是怎么样实现的，也不用考虑它们各自可能会如何演化。适配器的这种方式不需要对两个独立设计的类中任一个进行重新设计，就能够使它们协同工作
---
## 行为型模式一
    * 观察者模式
    * 模板模式
    * 命令模式
    * 状态模式
    * 职业链模式
* 具体对象间，相互直到的越少越好，这样发生改变时才不至于互相影响，在观察者模式中，目标和观察者之间不是紧密耦合的，它们可以属于一个系统之间的不同抽象层次，目标所知道仅仅是它有一系列的观察者，每个观察者实现Observer的简单接口，观察者属于哪个具体类，目标是不知道的
* 代码重复是编程中最常见的、最糟糕的坏味道，如果我们再一个以上的地方看到相同的程序结构，那么可以肯定，设法将它们合二为一，程序会变为更好。但是完全想同的代码当然存在明显的重复，而微妙的重复会出现在表面不同但是本质相同的的结构或处理步骤中。模板方法模式由一个抽象类组成，这个抽象类定义了需要覆盖的可能有不同实现的模板方法，每个从这个抽象类派生的具体类将为此模板实现新方法。这样就使得，所有可重复的代码都提炼到抽象类中了，这就实现了代码的重用。
* 命令模式将调用操作的对象与知道如何实现该操作的对象解耦，而这就意味着可以在两者之间处理很多事；还可以在不同的时刻指定、排列和执行请求；还可以在实施操作前将状态存储起来，以便支持取消/重做的操作；甚至可以记录整个操作的日志，以便可以在系统出问题时查找原因并回复重做。这些意味着命令模式支持事物，要么所有的命令全部执行成功，要么恢复到什么也没执行的状态
* 多个对象可以处理一个请求，哪个对象处理请求事先并不知道，要在运行时刻自动确定，此时，最好的办法就是让请求发送者与具体处理者分离，让客户在不明确指定接受者的情况下，提交一个请求，然后由所有能处理这请求的对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止
* 状态模式提供了一个更好的办法来组织与特定状态相关的代码，决定代码转移的逻辑不在单块的if或switch中，而是分布在各个状态子类之间中，所以通过定义新的子类可以很容易地增加新的状态和转换
---
## 行为型模式二
    * 解释器模式
    * 中介者模式
    * 访问者模式
    * 策略模式
    * 备忘录模式
    * 迭代器模式
* 面向对象设计鼓励将行为分布到各个对象中，这种分布可能会导致对象间有许多连接，也就是说，有可能每一个对象都需要知道其它许多对象，对象之间的大量相互连接使得一个对象似乎不太可能在没有其它对象的支持下工作，这对于应对变化是不利的，任何较大的改动都很困难，中介者模式提倡将集体行为封装在一个独立的中介者对象来避免这个问题，中介者负责控制和协调一组对象间的交互。中介者充当了一个中介以使组中的对象不再相互显示引用。这些对象仅知道中介者，从而减少相互连接的数目
* 备忘录模式可以避免暴露一些只应由对象A管理却又必须存储在对象A之外的信息。备忘录欧式把可能很复杂的对象A的内部信息对其他对象屏蔽起来，从而保持了封装边界